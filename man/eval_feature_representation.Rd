% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval_feature_representation.R
\name{eval_feature_representation}
\alias{eval_feature_representation}
\alias{eval_feature_representation,ConservationProblem,numeric-method}
\alias{eval_feature_representation,ConservationProblem,matrix-method}
\alias{eval_feature_representation,ConservationProblem,data.frame-method}
\alias{eval_feature_representation,ConservationProblem,Spatial-method}
\alias{eval_feature_representation,ConservationProblem,sf-method}
\alias{eval_feature_representation,ConservationProblem,Raster-method}
\title{Evaluate feature representation}
\usage{
eval_feature_representation(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,numeric}(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,matrix}(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,data.frame}(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,Spatial}(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,sf}(x, solution)

\S4method{eval_feature_representation}{ConservationProblem,Raster}(x, solution)
}
\arguments{
\item{x}{\code{\link[=problem]{problem()}} (i.e. \code{\linkS4class{ConservationProblem}}) object.}

\item{solution}{\code{numeric}, \code{matrix}, \code{data.frame},
\code{\linkS4class{Raster}}, \code{\linkS4class{Spatial}},
or \code{\link[sf:sf]{sf::sf()}} object.
The argument should be in the same format as the planning unit cost
data in the argument to \code{x}.
See the Solution format section for more information.}
}
\value{
\code{\link[tibble:tibble]{tibble::tibble()}} object describing feature representation.
Here, each row describes a specific statistic (e.g. different management
zone) for a specific feature.
It contains the following columns:

\describe{

\item{statistic}{\code{character} description of the representation statistic.
The representation statistics associated with the \code{"overall"} value
in this column are calculated using entire solution
(including all management zones if there are multiple zones).
If multiple management zones are present, then representation statistics
are also provided for each zone separately. In such cases,
these statistics are associated with values, in this column,
that correspond to the zone names.}

\item{feature}{\code{character} name of the feature.}

\item{total_amount}{\code{numeric} total amount of each feature available
in the entire conservation planning problem
(not just planning units selected within the solution).
It is calculated as the sum of the feature data,
supplied when creating a \code{\link[=problem]{problem()}} object
(e.g. presence/absence values).}

\item{absolute_held}{\code{numeric} total amount of each feature secured within
the solution. It is calculated as the sum of the feature data,
supplied when creating a \code{\link[=problem]{problem()}} object
(e.g. presence/absence values), weighted by the status of each
planning unit in the solution (e.g. selected or not for prioritization).}

\item{relative_held}{\code{numeric} proportion of
each feature secured within the solution. It is calculated
by dividing values in the \code{"absolute_held"} column by those in the
\code{"total_amount"} column.}

}
}
\description{
Calculate how well features are represented by a solution
to a conservation planning \code{\link[=problem]{problem()}}.
This function reports information for each and every feature,
and each and every zone, within a conservation planning problem.
}
\section{Solution format}{

The argument to \code{solution} must be in the same format as
the planning unit data in the argument to \code{x}
(e.g. in terms of data representation, dimensionality, and spatial
attributes).
For example, if the planning unit data in \code{x} is a \code{numeric}
vector, then the argument to \code{solution} must be a \code{numeric} vector
with the same number of elements.
Similarly, if the planning units in \code{x} are a \code{data.frame}, then the
argument to \code{solution} must also be a \code{data.frame} with each
column corresponding to a different zone, each row corresponding to a
different planning unit, and cell values corresponding to the solution value.
Additionally, if the planning unit data in \code{x} is
a \code{\linkS4class{Raster}} object, then the argument to
\code{solution} must also be a \code{\linkS4class{Raster}} object with
the same dimensionality (rows and columns), resolution, extent, and
coordinate reference system.
Furthermore, if the planning unit data in \code{x} is a
\code{\linkS4class{Spatial}} or \code{\link[sf:sf]{sf::sf()}} object then the
argument to \code{solution} must also be a \code{\linkS4class{Spatial}}
or \code{\link[sf:sf]{sf::sf()}} object (respectively) with the same spatial information
(e.g. polygons and coordinate reference system), and contain columns
corresponding to different zones, and cell values corresponding to the
solution values.

The argument to \code{solution} must also have missing (\code{NA}) values for planning
units that have missing (\code{NA}) cost values.
In other words, the solution must have missing (\code{NA}) values in the
same elements, cells, or pixels (depending on the cost data format) as the
planning unit cost data.
For example, if the planning unit data are a \code{\linkS4class{Raster}} object,
then the argument to \code{solution} must have missing (\code{NA}) values in
the same pixels as the planning unit cost data.
Similarly, if the planning unit data are a
\code{\linkS4class{Spatial}}, \code{\link[sf:sf]{sf::sf()}}, or \code{data.frame} object, then
the solution must have missing (\code{NA}) values in the same cells
as the planning unit cost data columns.
If an argument is supplied to \code{solution} where
the missing (\code{NA}) values in the argument to solution do not match
those in the planning unit cost data, then an error will be thrown.
}

\examples{
# set seed for reproducibility
set.seed(500)

# load data
data(sim_pu_raster, sim_pu_polygons, sim_pu_zones_sf, sim_features,
     sim_pu_zones_stack, sim_features_zones)

# create a simple conservation planning dataset so we can see exactly
# how feature representation is calculated
pu <- data.frame(id = seq_len(10), cost = c(0.2, NA, runif(8)),
                 spp1 = runif(10), spp2 = c(rpois(9, 4), NA))

# create problem
p1 <- problem(pu, c("spp1", "spp2"), cost_column = "cost") \%>\%
      add_min_set_objective() \%>\%
      add_relative_targets(0.1) \%>\%
      add_binary_decisions()

# create a solution
# specifically, a data.frame with a single column that contains
# binary values indicating if each planning units was selected or not
s1 <- data.frame(s = c(1, NA, rep(c(1, 0), 4)))
print(s1)

# calculate feature representation
r1 <- eval_feature_representation(p1, s1)
print(r1)

# let's verify that feature representation calculations are correct
# by manually performing the calculations and compare the results with r1
## calculate total amount for each feature
print(setNames(
  c(sum(pu$spp1, na.rm = TRUE),
    sum(pu$spp2, na.rm = TRUE)),
  c("spp1", "spp2")))

## calculate absolute amount held for each feature
print(setNames(
  c(sum(pu$spp1 * s1$s, na.rm = TRUE),
    sum(pu$spp2 * s1$s, na.rm = TRUE)),
  c("spp1", "spp2")))

## calculate relative amount held for each feature
print(setNames(
  c(sum(pu$spp1 * s1$s, na.rm = TRUE) / sum(pu$spp1, na.rm = TRUE),
    sum(pu$spp2 * s1$s, na.rm = TRUE) / sum(pu$spp2, na.rm = TRUE)),
  c("spp1", "spp2")))

\dontrun{
# solve the problem using an exact algorithm solver
s1_2 <- solve(p1)
print(s1_2)

# calculate feature representation in this solution
r1_2 <- eval_feature_representation(p1, s1_2[, "solution_1", drop = FALSE])
print(r1_2)

# build minimal conservation problem with raster data
p2 <- problem(sim_pu_raster, sim_features) \%>\%
      add_min_set_objective() \%>\%
      add_relative_targets(0.1) \%>\%
      add_binary_decisions()

# solve the problem
s2 <- solve(p2)

# print solution
print(s2)

# calculate feature representation in the solution
r2 <- eval_feature_representation(p2, s2)
print(r2)

# plot solution
plot(s2, main = "solution", axes = FALSE, box = FALSE)
}
# build minimal conservation problem with polygon (Spatial) data
p3 <- problem(sim_pu_polygons, sim_features, cost_column = "cost") \%>\%
      add_min_set_objective() \%>\%
      add_relative_targets(0.1) \%>\%
      add_binary_decisions()
\dontrun{
# solve the problem
s3 <- solve(p3)

# print first six rows of the attribute table
print(head(s3))

# calculate feature representation in the solution
r3 <- eval_feature_representation(p3, s3[, "solution_1"])
print(r3)

# plot solution
spplot(s3, zcol = "solution_1", main = "solution", axes = FALSE, box = FALSE)
}
# build multi-zone conservation problem with raster data
p4 <- problem(sim_pu_zones_stack, sim_features_zones) \%>\%
      add_min_set_objective() \%>\%
      add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5,
                                  ncol = 3)) \%>\%
      add_binary_decisions()
\dontrun{
# solve the problem
s4 <- solve(p4)

# print solution
print(s4)

# calculate feature representation in the solution
r4 <- eval_feature_representation(p4, s4)
print(r4)

# plot solution
plot(category_layer(s4), main = "solution", axes = FALSE, box = FALSE)
}

# build multi-zone conservation problem with polygon (sf) data
p5 <- problem(sim_pu_zones_sf, sim_features_zones,
              cost_column = c("cost_1", "cost_2", "cost_3")) \%>\%
      add_min_set_objective() \%>\%
      add_relative_targets(matrix(runif(15, 0.1, 0.2), nrow = 5,
                                  ncol = 3)) \%>\%
      add_binary_decisions()
\dontrun{
# solve the problem
s5 <- solve(p5)

# print first six rows of the attribute table
print(head(s5))

# calculate feature representation in the solution
r5 <- eval_feature_representation(p5, s5[, c("solution_1_zone_1",
                                        "solution_1_zone_2",
                                        "solution_1_zone_3")])
print(r5)

# create new column representing the zone id that each planning unit
# was allocated to in the solution
s5$solution <- category_vector(s5[, c("solution_1_zone_1",
                                      "solution_1_zone_2",
                                      "solution_1_zone_3")])
s5$solution <- factor(s5$solution)

# plot solution
plot(s5[, "solution"])
}
}
\seealso{
\code{\link[=problem]{problem()}}, \link{evaluation}.
}
